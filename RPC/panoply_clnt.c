/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "panoply.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

boolean *
creercompte_1(compte *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, CREERCOMPTE,
		(xdrproc_t) xdr_compte, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
seconnecter_1(compte *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, SECONNECTER,
		(xdrproc_t) xdr_compte, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

compte *
affichercompte_1(int *argp, CLIENT *clnt)
{
	static compte clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AFFICHERCOMPTE,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_compte, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
nombrecompte_1(void *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NOMBRECOMPTE,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
creerabonnement_1(abonnement *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, CREERABONNEMENT,
		(xdrproc_t) xdr_abonnement, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
nombreabonnement_1(void *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NOMBREABONNEMENT,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

abonnement *
afficherabonnement_1(int *argp, CLIENT *clnt)
{
	static abonnement clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AFFICHERABONNEMENT,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_abonnement, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
majunabonnement_1(abonnement *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, MAJUNABONNEMENT,
		(xdrproc_t) xdr_abonnement, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
affectationabonnement_1(compte *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AFFECTATIONABONNEMENT,
		(xdrproc_t) xdr_compte, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
creercollection_1(collection *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, CREERCOLLECTION,
		(xdrproc_t) xdr_collection, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
nombrecollection_1(void *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NOMBRECOLLECTION,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

collection *
affichercollection_1(int *argp, CLIENT *clnt)
{
	static collection clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AFFICHERCOLLECTION,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_collection, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
associervetementcollection_1(vetement *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, ASSOCIERVETEMENTCOLLECTION,
		(xdrproc_t) xdr_vetement, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
creervetement_1(vetement *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, CREERVETEMENT,
		(xdrproc_t) xdr_vetement, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

vetement *
affichervetement_1(int *argp, CLIENT *clnt)
{
	static vetement clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AFFICHERVETEMENT,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_vetement, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
nombrevetement_1(void *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NOMBREVETEMENT,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

boolean *
louervetement_1(location *argp, CLIENT *clnt)
{
	static boolean clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, LOUERVETEMENT,
		(xdrproc_t) xdr_location, (caddr_t) argp,
		(xdrproc_t) xdr_boolean, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

int *
nombrelocation_1(void *argp, CLIENT *clnt)
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, NOMBRELOCATION,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

location *
afficherlocation_1(int *argp, CLIENT *clnt)
{
	static location clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, AFFICHERLOCATION,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_location, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
